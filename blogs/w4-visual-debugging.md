# W4 Visual Debugging

Author: Junzhe Tai

Debugging is a very common and unavoidable task for programmers. We typically use logging when dealing with software runtime analysis, explaining failures and crashes, and investigating user behaviors.In everyday development, we often face this situation: the program runs without errors, but the results are not what we expected. So we start adding print statements, setting breakpoints, tracking variables and so on. These methods are simple and effective, but interpreting the log output displayed in the console or terminal is often challenging. For example, log statements within loops can generate massive amounts of log information. Furthermore, log output is organized linearly based on the order of program execution, making it difficult to connect log statements in different locations. Programmers often adopt strategies, such as using spacing and special characters, give logs timestamps and contexts and so on. However, in order to better solve the pain points in debugging, more and more papers point to visual debugging.

### Introduction to visual debugging

The importance visual debugging lies in transforming the abstract program state into a graphical representation that conforms to human visual perception, which could help developers to identify "patterns" and "abnormalities" in the program more efficiently[1]. According to cognitive load theory, effective multimedia design can reduce irrelevant cognitive load and allocate more cognitive resources to other tasks [2].

### Pain points in debugging with logging

There are roughly four pain points in current logging[3]：

1.Logged Output Lacking a Meaningful Organization.
The lack of a meaningful organi zation in logs creates significant challenges when programmers try to understand logs. For example, When programmers insert logging statements in a loop to track variable changes, they often need to comment or un-comment other log statements in the program, scroll back and forth in the console panel to locate all related messages, or adjust the log output format to make messages of interest more distinctive.This is because programmers find it difficult to find useful information in a large amount of log output.

2.Data Structures Lacking Informative Visualizations and Interaction.
Modern browsers do keep arrays or JSON objects in expandable structures, but when these objects become deeply nested, the logs become unreadable. If you want to log the specific properties deep in the data structure, you need to switch back to the source code and write new log statements that can access the property. Interpreting numbers can also be challenging when it comes to position and dimensions. For example, a value like (250, 480) might represent a screen position—but how large is that position on the actual UI?

3.Loss of Context due to Frequent View Switching.
Debugging often means juggling between the console, the code editor, the webpage, and the DOM inspector. Each switch breaks concentration.This kind of view-switching makes it difficult to connect logs with their source, slowing down debugging and increasing cognitive load.

4.Trade-offs when Crafting and Interpreting Logs. Because logging is a temporary debugging tool, most developers don’t invest much effort in making logs clean or readable.

So our goals in visual debugging are:

1.Offering Meaningful and Informative Log Structures.

2.Supporting Interactive and Visual Logging.

3.Embedding Logs within Contexts.

4.Minimum Effort for the Desired Enhancements.

### Visual debugging tools: Log-it introduction

We introduce a tool born to solve the above four pain points: _Log-it_[3]. _Log-it_'s core abstraction is a stream, which aggregates all log entries generated by the same log() statement at different times. Each stream has three parts: a header, a body, and a menu. The Stream Header can be dragged to relocate the Stream, and its crosshairs can be dragged to attach the Streams to page elements. The Stream Body hosts the log outputs produced by the log() statement. The Stream Menu offers a set of controls for the Stream, you can pause or resume logging at any time, collapse the stream to focus on the latest value, or remove the stream entirely after it has served its purpose. Importantly, these controls operate on individual log statements, not the entire program, providing developers with a tighter feedback loop.

_Log-it_ is interactive. When inspecting complex objects, you can highlight specific attributes all at once, and this highlighting is automatically applied to each log entry in the stream. This is synchronized across time if you expand or collapse a portion of the data structure.

_Log-it_ also redesigns how logs are represented. For example, a stream of values ​​can be transformed into a simple bar chart, with changes in values ​​translated into changes in shape. You can choose to view only the latest values ​​or view the entire history in a heatmap-like format. These lightweight visualizations allow users to spot patterns at a glance—especially during debugging.

Furthermore, _Log-it_ has context. Each log statement is assigned a color, which is shared across the code editor and visual flow, allowing users to easily associate what's on the screen with its source in the code. The log flow can also be physically attached to page elements, so the log moves along with the UI it describes. When a problem occurs, the log not only tells you where the problem is, but also where the problem originates.

###Result

Although _Log-it_ has not stated in user studies how much efficiency did visual debugging improve, many related papers indicate that visual debugging can improve the efficiency of completing tasks by ~ 30% - 200%, and can shorten debugging time by ~ 2 - 8 times [4][5][6][7].

###Future Work

In the future, we can combine artificial intelligence to achieve more functions, such as log filtering and automatically highlighting relevant events. Furthermore, user personalization is also a significant way to enhance the user experience. Finally, visual debugging can be extended to new fields such as virtual reality and game design, where the need for visual debugging is even more urgent.

###References

[1] Shahnabati F, Sabourifard A, Amiri SH, Bosaghzadeh A, Ebrahimpour R. Cognitive load and visual attention assessment using physiological eye tracking measures in multimedia learning. PLoS One. 2025 Dec 1;20(12):e0337195. doi: 10.1371/journal.pone.0337195. PMID: 41325323; PMCID: PMC12668483.

[2] Imed Bouchrika. (2026, January). 5 Cognitive Theories Backing the Use of Visuals in Educational Content. https://research.com/education/cognitive-theories-backing-the-use-of-visuals-in-educational-content

[3] Jiang, P., Sun, F., & Xia, H. (2023, April). Log-it: Supporting Programming with Interactive, Contextual, Structured, and Visual Logs. In Proceedings of the 2023 CHI Conference on Human Factors in Computing Systems (pp. 1-16).

[4] Amy J. Ko and Brad A. Myers. 2004. Designing the whyline: a debugging interface for asking questions about program behavior. In Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI '04). Association for Computing Machinery, New York, NY, USA, 151–158. https://doi.org/10.1145/985692.985712

[5] M. Willembrinck, S. Costiou, A. Etien and S. Ducasse, "Time-Traveling Debugging Queries: Faster Program Exploration," 2021 IEEE 21st International Conference on Software Quality, Reliability and Security (QRS), Hainan, China, 2021, pp. 642-653, doi: 10.1109/QRS54544.2021.00074.

[6] Amy J. Ko and Brad A. Myers. 2004. Designing the whyline: a debugging interface for asking questions about program behavior. In Proceedings of the SIGCHI Conference on Human Factors in Computing Systems (CHI '04). Association for Computing Machinery, New York, NY, USA, 151–158. https://doi.org/10.1145/985692.985712

[7] Ko, Andrew & Myers, Brad. (2009). Finding Causes of Program Output with the Java Whyline. 1569-1578. 10.1145/1518701.1518942.
